### MySQL
1. 什么是事务
事务是指满足ACID特性的一组操作，可以通过commit提交一个事务，也可以使用rollback进行回滚
2. 数据库ACID


    2.1 原子性（Atomicity）
        原子性指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的sql语句，要么全部
        成功，要么全部执行失败。
    2.2 一致性（Consistency）
        事务必须使数据库从一个一致性状态转换到另一个一致性状态
    2.3 隔离性（lsolation）
        是指多个用户并发访问数据库时。比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发
        事务之间要相互隔离。
    2.4 持久性（durability）
        一旦事务提交，则其所做的修改将永远存到数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。
        
3.数据库中的范式

    3.1 1NF 属性不可再分
    3.2 2NF 属性完全依赖于主键   一对多要拆
    3.3 3NF 属性不依赖于其他非主属性 Sno -> sdept-> Mname
        如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这个称作传递依赖于
        主属性。
    反三范式
    没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，提高读性能，就必须降低范式标准，适当保留冗余数据。
    具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，
    减少了查询时的关联，提高查询效率，
    因为在数据库的操作中查询的比例要远远大于DML的比例。但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。

4.并发一致性问题
    
    4.1 丢失修改
        T1和T两个事务都对一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。
    4.2 脏读---->解决----设置事务隔离级别READ-COMMITTED
        读取到未提交的事务做的修改。即一个事务读取另外一个事务还没提交的数据
    4.3 不可重复读---->解决----设置事务隔离级别REPEATABLE_READ
        是指在一个事务内，多次读取同一数据，在这个事务还没有结束时，另一个事务也访问这个数据，那么在第一个事务中两次读取
        数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。
    4.4 幻读---->解决----设置事务隔离级别SERIALIZABLE_READ
        事务1读取一条指定的where子句返回的结果集，然后另外一个事务2新插入一行记录，恰好可以满足事务1所查询条件，然后事务1
        再次对表进行检索，看到了事务2插入的数据。

5.事务隔离级别

     5.1 串行化
     所有事务一个接着一个的执行，可以避免幻读，对于基于锁实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取
     范围锁，如果不是基于锁实现并发控制的数据库，则检查到又违反串行操作的事务时，需回滚该事务。
     
     5.2 可重复读
     所有被select读取的数据都不能被修改，这样就可以避免一个事务前后读取到数据不一致的情况。但是却没有方法控制幻读，因为这个时候
     其他事务不能更改所选的数据，但是可以增加数据。即前一个事务有锁但是没有范围锁。
     5.3 读已提交
     被读取的数据可以被其他事务修改，这样可能导致不可重复读，也就是说，事务读取的时候获取读锁，但是读完之后立即释放，而写锁则是事务提交
     之后才释放，释放读锁之后，就可能被其他事务修改数据。
     5.4 读未提交
     最低的隔离等级，允许其他事务看到没有提交的数据，会导致脏读。

6.存储引擎（MyISAM、InnoDB）
    mysql5.5之后默认存储引擎是InnoDB
    
    6.1 MyISAM
        特性：
            并发性和锁级别(对于读写混合操作不好，为表级锁，写入和读互斥)
            表损坏修复
            myISAM表支持的索引类型（全文索引）
            myISAM支持表压缩
        应用场景
            没有事务
            只读类应用（插入不频繁，查询非常频繁）
            空间类应用 （唯一支持空间函数的引擎）
            做很多count计算
    6.2 InnoDB
        特性
            InnoDB为事务性存储引擎
            完全支持事务的ACID特性
            InnoDB支持行级锁
            行级锁可以最大程度的支持并发
            行级锁是由存储引擎实现的
        场景
            可靠性要求比较高，或者要求事务
            表更新和查询都相当频繁，并且锁的的机会比较大的情况。
    6.3 区别
            myISAM不支持外间而InnoDB支持
            MyISAM是非事务安全型的，而InnoDN是事务安全型的
            myISAM锁的粒度是表级，而InnoDB支持行级锁定
            myISAM支持全文索引，而InnoDN不支持全文索引
            myISAM相对简单，所以在效率上要优于InnoDB 小型应用可以考虑使用MyISAM
            InnoDb比myISAM表安全
            
            MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。
            而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。
            这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
            可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，
            所以InnoDB要求表必须有主键（MyISAM可以没有），
            如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，
            则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。
            第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。
            换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：

7.索引
    
    7.1 索引使用的场景
        对于非常小的表，大部分情况下简单全表扫描比建立索引更有效
        对于中到大型的表，索引就非常有效
        但是对于特大型的表，建立和维护索引的代价将会随之增长，这种情况下，需要用到一种技术可以直接区分初需要查询的一组数据
        而不是一条一条的匹配。比如分区技术
        
    7.2 B Tree原理
        B-Tree
![alt](https://frank-lam.github.io/fullstack-tutorial/assets/06976908-98ab-46e9-a632-f0c2760ec46c.png)
    
     定义一条数据记录为一个二元组，B-Tree满足下列数据结构
        1.所有叶节点具有相同的深度，也就是说B-Tree是平衡的
        2.一个节点中的key从左到右非递减排列
        3.某个指针的左右相邻key分别是key i和key i+1且不为null 则该指针指向节点的所有key>=key i且key<=key i+1
        查找算法，首先在跟节点进行二分查找，如果找到则返回对应节点的data否则在相应区间的指针指向的节点进行递归查找
        
        B+Tree
![alt](https://frank-lam.github.io/fullstack-tutorial/assets/061c88c1-572f-424f-b580-9cbce903a3fe.png)
        
        每个节点的指针上限为2d而不是2d+1
        内节点不存储data，只存储key
        叶子节点不存储指针
![alt](https://frank-lam.github.io/fullstack-tutorial/assets/061c88c1-572f-424f-b580-9cbce903a3fe.png)
        
        一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree基础上进行优化，在叶子节点增加了顺序访问指针。这个优化的
        目的是为了提高区间访问性能
        BTree索引优势
        1、更少的检索次数
        平衡树检索数据的时间复杂度等于树高h而树高大致为O(h)=O(logdN)其中d为每个节点的出度
        红黑树的出度为2而BTree的出度一般非常大，红黑树的树高h很明显比BTree大非常多，因此检索次数也就更多
        B+tree相比于B-Tree更适合外存索引，因为B+Tree内节点去掉了data域，因此可以拥有很大的出度，检索效率会更高。
        2、利用计算机预读特性
        为了减少磁盘IO磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，
        并且只需要很短的旋转时间，因此速度会非常快。
8.索引分类
    
    1.B+Tree索引
        是大多数mysql存储引擎的默认索引类型，因为不需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多，除了用于查找，
        还可用于排序和分组
        
        可以指定多个列作为索引列，多个索引咧共同组成建
        
        B+Tree索引适用于全建值、键值范围和键值前缀查找，其中键值前缀查找只适用于最左前缀查找
        
        如果不是按照索引列的顺序进行查找，则无法使用索引。
        
        InnoDB的B+Tree索引分为主索引和辅助索引
        
        主索引的叶子节点data域记录完整的数据记录，这种索引方式称为聚簇索引，因为无法把数据行存放在两个不同的地方，所以一个表只能
        有一个聚簇索引。
![alt](https://frank-lam.github.io/fullstack-tutorial/assets/c28c6fbc-2bc1-47d9-9b2e-cf3d4034f877.jpg)        
       
        辅助索引的叶子接待你的data域，记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后到主索引中进行查找。
![alt](https://frank-lam.github.io/fullstack-tutorial/assets/7ab8ca28-2a41-4adf-9502-cc0a21e63b51.jpg)      
    
    2.哈希索引
    
        InnoDB引擎又一个特殊的功能叫自适应哈希索引，当某个索引值被使用的非常频繁的时候，会在B+Tree索引之上在创建一个哈希索引
        这样就让B+tree索引具有哈希索引的一些优点，比如快速的哈希查找。
        哈希索引能以O（1）时间进行查找，但是失去了有序性，它具有以下限制
        无法用于排序和分组
        只支持精确查找，无法用于部分查找和范围查找
          
    3.全文索引
        MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等，查找条件使用MATCHAGAINST而不是普通的WHERE
        全文索引一般使用倒序排索引实现，它记录着关键词到其所在文档的映射。
        InnoDB存储引擎在mysql5.6.4版本中也支持全文索引。
        
    4.空间数据索引   
        MyISAM存储引擎支持空间数据索引，可以用于地理数据存储，空间数据索引会从所有纬度来索引数据，可以有效地使用任意纬度来进行组合查询
        
9.索引的特点

     1.可以加快数据库检索速度
     2.降低数据库插入修改删除的速度
     3.只能创建在表上不能创建在试图上
     4.既可以直接创建，又可以间接创建
     5.可以在优化隐藏中使用索引
     6.使用查询处理器执行sql语句，在一个表上一次只能使用一个索引
     优点
     1.创建唯一性索引保证数据库表中每一行数据的唯一性
     2.大大加快数据的检索速度，这是创建索引最主要的原因
     3.加速数据表之间的链接，特别是在实现数据的参考完整性方面又特别的意义
     4.在使用分组和排序子句进行检索数据时，同样可以显著减少查询中分组和排序的时间
     5.通过使用索引，可以在查询中优化隐藏器，提高系统性能
     缺点
     1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
     2.创建索引要占有物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引空间更大
     3.当对表中的数据进行增加，修改删除的时候，索引也需要为空，降低数据维护的速度
     
10.索引失效
    
    1.如果条件中有or即使其中有条件带索引也不会使用 select * from table where name='1' or name='2'
    2.复合索引，如果索引列不是复合索引列的一部分，则不使用索引（不符合最左前缀）
        （key1,key2） select * from table where key2='2'; 
    3.如果like是以%开始的则不适用索引
        select * from table where name like '%a';
    4.如果列为字符串，则where条件中必须将字符串常量加引号，否则会使索引失效
        select * from table where name=1;
    5.如果mysql估计使用全表比使用索引快，则不使用索引 key均匀分布在1到100之间
        select * from table where key>1 and key<90
        
11.什么情况下适合建立索引          
    
    1.为经常出现在关键字order by 、group by distinct后面的字段，建立索引
    2.在union等稽核操作的结果集字段上、建立索引，其建立索引的目的同上
    3.为经常做查询选择where后的字段、建立索引
    4.在经常使用做表链接的join属性上，建立索引
    5.考虑使用索引覆盖，对数据很少被更新的表，如果用户经常只查询其中几个字段，可以考虑在这几个字段上建立索引
12.为什么使用B+Tree
   
   
    B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有data域，所以从innodb的角度来看，B+树
    是用来充当索引的，一般来说索引非常大，尤其关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占有，
    索引也会被存储到磁盘上。
    
    衡量mysql查询效率，磁盘的IO次数
    考虑树的深度说起
13.创建索引
    
   ```$xslt
     ALTER TABLE table_name ADD INDEX index_name (column_list)
     ALTER TABLE table_name ADD UNIQUE (column_list)
     ALTER TABLE table_name ADD PRIMARY KEY (column_list)
     CREATE INDEX index_name ON table_name (column_list)
     CREATE UNIQUE INDEX index_name ON table_name (column_list)
      DROP INDEX index_name ON talbe_name
      ALTER TABLE table_name DROP INDEX index_name
      ALTER TABLE table_name DROP PRIMARY KEY
   ```    
14. 主键、外键和索引的区别
    
    
    主键 唯一标示一条记录，不允许为空
    外键 是另外一个表的主键，可以重复，可以是空
    索引 该字段没有重复值，但可以有一个空值     
        
15.查询性能优化

    1.使用Explain进行分析。
    2.只返回必要的列、行limit
    3.缓存重复查询的数据
    4.切分大的查询，分解大的链接查询

       
 [很牛的讲解索引文章](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
 
 
        
 
        
                                
            