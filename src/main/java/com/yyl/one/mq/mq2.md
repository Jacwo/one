### 为什么使用消息队列
1.优点：异步、解偶、统一管理所有消息
2.缺点：系统复杂度增加、消息发送的重复消费、消息丢失等问题
### 接口幂等
接口幂等性：使用相同参数重复执行，并能获得相同结果。
1。使用唯一标识：如订单号+业务场景这样的唯一标识。执行操作前先根据这个全局唯一ID是否存在，
判断是否执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、redis等。
如果存在则表示该方法已经执行。存储的时候加入过期时间，防止机器宕机后，全局ID锁死导致操作无法继续
2。去重表：适用于在业务中有唯一标的插入场景中。如支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。
这时，我们就可以建一张去重表（流水表），并且把唯一标识作为唯一索引，在我们实现时，
把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。
3。多版本控制：适合在更新的场景中，比如我们要更新商品的名字，这时我们就可以在更新的接口中增加一个版本号，来做幂等。
- update goods set name=#{newName},version=#{version} where id=#{id} and version<${version}

###顺序消费
针对顺序消费问题，只要发送者保证把消息发送到topic的相同队列中即可。

- 对于Kafka，生产者发送消息时可以指定固定Partition的topic下。
- 对于rocketmq，RocketMQ提供了MessageQueueSelector队列选择机制 
Hash取模法将同一个操作的消息发送到同一个Queue里面。

### RocketMQ[Top]
消息生产者（Producer）：负责生产消息，一般由业务系统负责生产消息。
RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。
消息消费者（Consumer）：负责消费消息，一般是后台系统负责异步消费。

提供了两种消费形式：拉取式消费、推动式消费。

拉取式消费：应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。
推动式消费：Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。


提供两种消费模式：集群消费和广播消费

集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。
广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。

主题（Topic）：表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。
代理服务器（Broker Server）：消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等
名字服务（Name Server）：名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。
生产者组（Producer Group）：同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。
消费者组（Consumer Group）：同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费和广播消费。

标签（Tag）：为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。






    